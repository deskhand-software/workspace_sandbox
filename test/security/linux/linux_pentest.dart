@TestOn('linux')
import 'dart:io';
import 'package:test/test.dart';
import 'package:workspace_sandbox/workspace_sandbox.dart';

void main() {
  group('Linux Security Pentest', () {
    late Workspace ws;

    setUp(() {
      ws = Workspace.ephemeral(
        options: const WorkspaceOptions(allowNetwork: false),
      );
    });

    tearDown(() async {
      await ws.dispose();
    });

    test('Exploit 1: /etc/shadow Read Attack', () async {
      final result = await ws.run('cat /etc/shadow');

      if (result.exitCode == 0 && result.stdout.isNotEmpty) {
        fail('CRITICAL: Read access to /etc/shadow granted!');
      }
    });

    test('Exploit 2: Kernel Module Loading', () async {
      final result = await ws.run('insmod /tmp/fake_module.ko');

      if (result.exitCode == 0) {
        fail('CRITICAL: Kernel module load succeeded!');
      }
    });

    test('Exploit 3: Symlink Race Condition', () async {
      await ws.run('ln -s /etc/passwd linkfile');
      final result = await ws.run('echo HACKED >> linkfile');

      if (result.exitCode == 0) {
        final passwd = File('/etc/passwd');
        final content = await passwd.readAsString();
        if (content.contains('HACKED')) {
          print('CRITICAL BREACH DETECTED - Manual cleanup required');
          fail('CRITICAL: Symlink allowed writing to /etc/passwd!');
        }
      }
    });

    test('Exploit 4: Proc Filesystem Leak', () async {
      await ws.run('cat /proc/version');
      final hostPidTest = await ws.run('ls /proc/1');

      if (hostPidTest.exitCode == 0 && hostPidTest.stdout.contains('cmdline')) {
        print('INFO: /proc/1 visible (PID namespace not isolated)');
      }
    });

    test('Exploit 5: Cgroup Escape Attempt', () async {
      final result =
          await ws.run('echo \$\$ > /sys/fs/cgroup/user.slice/tasks');

      if (result.exitCode == 0) {
        fail('CRITICAL: Cgroup write access granted!');
      }
    });

    test('Exploit 6: Raw Socket Creation', () async {
      final cmd = '''python3 -c "
import socket
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    print('RAW_SOCKET_CREATED')
except PermissionError:
    print('BLOCKED')
"''';

      final result = await ws.run(cmd);

      if (result.stdout.contains('RAW_SOCKET_CREATED')) {
        fail('CRITICAL: Raw socket creation allowed!');
      }
    });

    test('Exploit 7: Mount Namespace Leak', () async {
      final result = await ws.run('cat /proc/mounts | grep /home');
      expect(result.exitCode, isNot(equals(139)));
    });

    test('Exploit 8: Fork Bomb Defense', () async {
      final stopwatch = Stopwatch()..start();
      final result = await ws.run('bash -c ":(){ :|:& };:"',
          options: const WorkspaceOptions(timeout: Duration(seconds: 3)));
      stopwatch.stop();

      expect(result.isCancelled, isTrue);
      expect(stopwatch.elapsed.inSeconds, lessThan(6));
    });
  });
}
