import 'dart:io';
import 'package:test/test.dart';
import 'package:workspace_sandbox/workspace_sandbox.dart';

void main() {
  group('Security Pentest Suite', () {
    late Workspace ws;
    late File hostSecretFile;
    const secretContent = 'SUPER_SECRET_HOST_DATA_V1';

    setUpAll(() async {
      final tempDir = Directory.systemTemp;
      hostSecretFile = File('${tempDir.path}/workspace_pentest_secret.txt');
      await hostSecretFile.writeAsString(secretContent);
    });

    tearDownAll(() async {
      if (await hostSecretFile.exists()) await hostSecretFile.delete();
    });

    setUp(() {
      ws = Workspace.secure(
        options: const WorkspaceOptions(sandbox: true, allowNetwork: false),
      );
    });

    tearDown(() async {
      await ws.dispose();
    });

    test('Exploit 1: Path Traversal (Read Protection)', () async {
      // Intentar leer archivo fuera del workspace
      // ../../../.../secret.txt
      final separator = Platform.pathSeparator;
      final steps = '..$separator' * 10;
      final target = '$steps${hostSecretFile.path}';

      // En Windows/Linux, cat/type debería fallar o ser bloqueado por permisos
      final cmd = Platform.isWindows ? 'type "$target"' : 'cat "$target"';

      final result = await ws.run(cmd);

      // Si lee el contenido secreto, fallamos
      if (result.stdout.contains(secretContent)) {
        fail('CRITICAL: Sandbox allowed READING outside workspace!');
      }
    });

    test('Exploit 2: Path Traversal (Write Protection)', () async {
      final separator = Platform.pathSeparator;
      final steps = '..$separator' * 10;
      final target = '$steps${hostSecretFile.path}.hacked';

      final cmd = 'echo HACKED > "$target"';
      await ws.run(cmd);

      final hackFile = File('${hostSecretFile.path}.hacked');
      if (await hackFile.exists()) {
        await hackFile.delete();
        fail('CRITICAL: Sandbox allowed WRITING outside workspace!');
      }
    });

    test('Exploit 3: Symlink Attack (Linux Only)', () async {
      if (Platform.isWindows)
        return; // Windows requiere admin para symlinks usualmente

      await ws.run('ln -s / host_root');
      await ws.run('echo "hacked" > host_root/tmp/hacked_host.txt');

      final hostLeakedFile = File('/tmp/hacked_host.txt');
      if (await hostLeakedFile.exists()) {
        await hostLeakedFile.delete();
        fail('CRITICAL: Symlink allowed writing to HOST /tmp!');
      }
    });

    test('Exploit 4: Network Bypass', () async {
      // Intento de conectar a 8.8.8.8
      String payload;
      if (Platform.isWindows) {
        payload =
            'powershell -Command "try { \$c = New-Object System.Net.Sockets.TcpClient(\'8.8.8.8\', 53); echo \'CONNECTED\' } catch { echo \'FAILED\' }"';
      } else {
        payload =
            'python3 -c "import socket; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(2); s.connect((\'8.8.8.8\', 53)); print(\'CONNECTED\')"';
      }

      final result = await ws.run(payload);
      if (result.stdout.contains('CONNECTED')) {
        // OJO: En HostStrategy (sandbox=false o fallback) esto pasará.
        // Este test valida si la estrategia de aislamiento REALMENTE aísla.
        // Si falla aquí y estás usando HostStrategy, es esperado.
        print(
            'Warning: Network connected. Are we using real Sandbox strategy?');
      }
    });

    test('Exploit 5: Fork Bomb / Resource Exhaustion', () async {
      // Ping a localhost (-n 10 = 10 segundos)
      final cmd = Platform.isWindows ? 'ping -n 10 127.0.0.1' : 'sleep 10';

      final stopwatch = Stopwatch()..start();

      final result = await ws.run(cmd,
          options: const WorkspaceOptions(
              // Timeout de la librería: 2 segundos
              timeout: Duration(seconds: 2),
              sandbox: true));

      stopwatch.stop();

      // Si esto falla con <false>, es que isCancelled no se seteó.
      expect(result.isCancelled, isTrue,
          reason: "Process should be cancelled. ExitCode: ${result.exitCode}");
      expect(stopwatch.elapsed.inSeconds, lessThan(6));
    });
  });
}
