import 'dart:io';
import 'package:test/test.dart';
import 'package:workspace_sandbox/workspace_sandbox.dart';

/// Security Pentest Suite (Red Team)
///
/// These tests simulate malicious agent behavior attempting to escape the sandbox.
/// They rely on native OS features and require the native library to be built.
void main() {
  group('Security Pentest Suite', () {
    late Workspace ws;
    late File hostSecretFile;
    const secretContent = 'SUPER_SECRET_HOST_DATA_V1';

    setUpAll(() async {
      // Create a "secret" file in the user's home directory or temp root.
      // This simulates a sensitive user file (e.g., .ssh/id_rsa).
      String basePath;
      if (Platform.isWindows) {
        basePath =
            Platform.environment['USERPROFILE'] ?? Directory.systemTemp.path;
      } else {
        basePath = Platform.environment['HOME'] ?? '/tmp';
      }

      // Ensure we don't overwrite something important
      hostSecretFile = File('$basePath/workspace_pentest_secret.txt');
      await hostSecretFile.writeAsString(secretContent);
      print('ðŸ”’ Created honeypot file at: ${hostSecretFile.path}');
    });

    tearDownAll(() async {
      if (await hostSecretFile.exists()) await hostSecretFile.delete();
    });

    setUp(() {
      // Enforce strict sandbox with NO network
      ws = Workspace.secure(
        options: const WorkspaceOptions(sandbox: true, allowNetwork: false),
      );
    });

    tearDown(() async {
      await ws.dispose();
    });

    // --- 1. FILESYSTEM ESCAPE ATTEMPTS ---

    test('Exploit 1: Path Traversal Escape (Classic ../)', () async {
      // Calculate path to the secret file relative to the workspace root.
      // Since we don't know the exact depth, we just spam ../
      final steps = '../' * 10;
      final cleanPath = hostSecretFile.path.startsWith('/')
          ? hostSecretFile.path.substring(1)
          : hostSecretFile.path;

      // Linux: ../../../../../tmp/secret.txt
      // Windows: ..\..\..\..\Users\User\secret.txt
      final target = '$steps$cleanPath';

      print('Trying to read: $target');

      // 1a. Try via Dart API (Should be blocked by _resolve logic)
      try {
        await ws.readFile(target);
        fail('VULNERABILITY: Dart API allowed path traversal!');
      } catch (e) {
        expect(e.toString(), contains('Security'),
            reason: 'Dart API should throw Security Exception for ".."');
      }

      // 1b. Try via Native Shell (Should be blocked by OS sandbox)
      // If the sandbox works, the process simply won't see the file.
      final cmd = Platform.isWindows ? 'type "$target"' : 'cat "$target"';
      final result = await ws.run(cmd);

      if (result.stdout.contains(secretContent)) {
        fail('CRITICAL: Native sandbox escape! Secret read: ${result.stdout}');
      }

      if (result.exitCode == 0) {
        // Special handling for WSL2 dev environments which might be permissive
        if (!Platform.isWindows && result.stdout.trim().isEmpty) {
          print(
              'WARNING: Command succeeded but output empty. Likely blocked but silent.');
        } else {
          // If exitCode 0 and output not empty/secret, it might have cat'ed nothing?
        }
      } else {
        // Expected behavior: "No such file or directory" or "Access denied"
        final errorMsg = result.stderr.toLowerCase();
        expect(
            errorMsg,
            anyOf(
                contains('no such file'),
                contains('cannot find'),
                contains('denied'),
                contains('no son correctos'), // Spanish Windows
                contains('incorrect'),
                contains(
                    'sintaxis de la etiqueta del volumen no son correctos') // Spanish Windows specific
                ),
            reason:
                'OS should report file missing or access denied. Got: $errorMsg');
      }
    });

    test('Exploit 2: Symbolic Link Attack (Linux Only)', () async {
      if (Platform.isWindows) return;

      // Try to create a symlink from inside the workspace to the root /
      await ws.run('ln -s / host_root');

      // Try to read /etc/passwd via the link
      final result = await ws.run('cat host_root/etc/passwd');

      if (result.stdout.contains('/home/')) {
        print(
            'Info: Symlink read /etc/passwd. This is generally acceptable if ReadOnly.');
      }

      // Try to write to /tmp via symlink (should be isolated tmpfs)
      // FIX: Remove unused variable warning by awaiting directly
      await ws.run('echo "hacked" > host_root/tmp/hacked_host.txt');

      // Check if file exists on HOST
      final hostLeakedFile = File('/tmp/hacked_host.txt');
      if (await hostLeakedFile.exists()) {
        await hostLeakedFile.delete(); // Cleanup
        fail('CRITICAL: Symlink allowed writing to HOST /tmp!');
      }
    });

    // --- 2. NETWORK EXFILTRATION ATTEMPTS ---

    test('Exploit 3: Network Bypass via Python/PowerShell Sockets', () async {
      // We disabled network in setUp(). Tools like curl might be missing,
      // so hackers use built-in scripting languages.

      String payload;
      if (Platform.isWindows) {
        // PowerShell TCP connection attempt
        payload =
            'powershell -Command "try { \$c = New-Object System.Net.Sockets.TcpClient(\'8.8.8.8\', 53); echo \'CONNECTED\' } catch { echo \'FAILED\' }"';
      } else {
        // Python socket attempt
        payload =
            'python3 -c "import socket; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(2); s.connect((\'8.8.8.8\', 53)); print(\'CONNECTED\')"';
      }

      // Check if language exists first
      final check = await ws
          .run(Platform.isWindows ? 'powershell -v' : 'python3 --version');
      if (check.exitCode != 0) {
        print('Skipping socket test: Scripting engine not found in sandbox.');
        return;
      }

      print('Attempting socket connection (Should Fail)...');
      final result = await ws.run(payload);

      if (result.stdout.contains('CONNECTED')) {
        fail('CRITICAL: Network isolation bypassed via raw Sockets!');
      }

      print(
          'Socket attempt result: ${result.stdout.trim()} ${result.stderr.trim()}');
    });

    // --- 3. RESOURCE EXHAUSTION (DoS) ---

    test('Exploit 4: Fork Bomb / Resource Exhaustion', () async {
      // Instead we test simple infinite loop with timeout.

      final cmd = Platform.isWindows
          ? 'cmd /c "for /L %i in (1,0,2) do echo loop"' // Infinite loop
          : 'sh -c "while true; do echo loop; sleep 1; done"';

      final stopwatch = Stopwatch()..start();

      // Run with short timeout
      final result = await ws.run(cmd,
          options: const WorkspaceOptions(
              timeout: Duration(seconds: 2), sandbox: true));

      stopwatch.stop();

      // FIX: Use isCancelled instead of exitCode to verify timeout behavior
      expect(result.isCancelled, isTrue,
          reason: 'Process should be killed by timeout');
      expect(stopwatch.elapsed.inSeconds, lessThan(5),
          reason: 'Timeout mechanism failed to kill rogue process quickly');
    });
  });
}
